# -*- coding: utf-8 -*-
# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/20_widgets.ipynb (unless otherwise specified).

__all__ = [
    "InputWidget",
    "InputFilesWidget",
    "OutputWidget",
    "FileSetTable",
    "WorkflowOutput",
]

# Cell
from abc import ABCMeta, abstractmethod
from datetime import datetime
from functools import partial
from typing import Any

from dharpa_toolbox.modules.workflows import DharpaWorkflow, ValueLocation
from ipywidgets import FileUpload, Output, Widget


class InputWidget(metaclass=ABCMeta):
    def __init__(self, input_item: ValueLocation):

        # if input_item.type != ValueLocationType.workflow_input:
        #     raise ValueError(f"Invalid input item, can only use '{ValueLocationType.workflow_input}', not '{input_item.type}'")

        self._input_item: ValueLocation = input_item

        self._widget: Widget = None

    def set_value(self, change: Any):

        self._input_item.module.set_input(self._input_item.value_name, change.new)

    @property
    def widget(self) -> Widget:

        if self._widget is not None:
            return self._widget

        self._widget = self._create_widget()
        self._widget.observe(self.set_value, names="value")
        return self._widget

    @abstractmethod
    def _create_widget(self) -> Widget:
        pass


class InputFilesWidget(InputWidget):
    def _create_widget(self) -> Widget:

        print("Creating widget")

        # uploaded_file_details = Output()
        file_upload = FileUpload(accept=".csv", multiple=False)

        return file_upload


class OutputWidget(metaclass=ABCMeta):
    def __init__(self, output_item: ValueLocation):

        # if output_item.type != ValueLocationType.workflow_output:
        #     raise ValueError(f"Invalid input item, can only use '{ValueLocationType.workflow_input}', not '{output_item.type}'")

        self._widget: Widget = self._create_widget()

        self._output_item: ValueLocation = output_item
        func = partial(self.value_changed, self._widget)

        self._output_item.module.state.outputs.observe(
            func, names=self._output_item.value_name
        )

    @property
    def widget(self) -> Widget:

        if self._widget is not None:
            return self._widget

    @abstractmethod
    def _create_widget(self) -> Widget:
        pass

    @abstractmethod
    def value_changed(self, widget: Widget, change: Any):

        pass


class FileSetTable(OutputWidget):
    def _create_widget(self) -> Widget:

        output = Output()
        return output

    def value_changed(self, widget: Widget, change):

        with widget:
            print(f"Updated: {datetime.now()}")
            print(change.new)


class WorkflowOutput(object):
    def __init__(self, workflow: DharpaWorkflow):

        self._workflow: DharpaWorkflow = workflow

    @property
    def workflow(self) -> DharpaWorkflow:
        return self._workflow

    def _assemble_output(self):

        for input_name, inp in self._workflow.inputs.traits().items():
            print(input_name)
            print(inp)
