# -*- coding: utf-8 -*-
# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/20_widgets.ipynb (unless otherwise specified).

# Cell
from abc import ABCMeta, abstractmethod
from datetime import datetime
from functools import partial
from typing import Any, Dict, Iterable, Mapping

import rich
from dharpa_toolbox.modules.core import ValueLocationType
from dharpa_toolbox.modules.files import DharpaFiles
from dharpa_toolbox.modules.workflows import ValueLocation
from ipywidgets import FileUpload, Output, Widget


class ItemWidget(metaclass=ABCMeta):
    def __init__(self, *items: ValueLocation, **more_items: ValueLocation):

        # if input_item.type != ValueLocationType.workflow_input:
        #     raise ValueError(f"Invalid input item, can only use '{ValueLocationType.workflow_input}', not '{input_item.type}'")

        self._input_items: Dict[str, ValueLocation] = {}
        self._output_items: Dict[str, ValueLocation] = {}

        for ii in items:
            self._add_item(ii.value_name, ii)
        for k, v in more_items.items():
            self._add_item(k, v)

        missing_inputs = set()
        missing_outputs = set()
        for n in self.required_input_names():
            if n not in self._input_items.keys():
                missing_inputs.add(n)
        for n in self.required_output_names():
            if n not in self._output_items.keys():
                missing_outputs.add(n)

        if missing_inputs or missing_outputs:
            msg = "Can't create widget, missing items: "
            if missing_inputs:
                msg = msg + f" {', '.join(missing_inputs)} (inputs)"
            if missing_outputs:
                msg = msg + f" {', '.join(missing_outputs)} (outputs)"

            raise ValueError(msg)

        self._widget: Widget = None

    def required_input_names(self) -> Iterable[str]:
        return []

    def required_output_names(self) -> Iterable[str]:
        return []

    def _add_item(self, name: str, item: ValueLocation):

        if item.direction == ValueLocationType.input:
            if name in self._input_items.keys():
                raise ValueError(
                    f"Can't add input item to widget, duplicate item name: {name}"
                )

            self._input_items[name] = item
        else:
            if name in self._output_items.keys():
                raise ValueError(
                    f"Can't add output item to widget, duplicate item name: {name}"
                )
            self._output_items[name] = item

            func = partial(self.output_value_changed, name)

            item.module.state.outputs.observe(func, names=item.value_name)

    def set_input_item_value(self, value_name: str, change: Any):

        # print(f"Widget value set: {change}")

        print("==========================================================")
        print(f"Widget '{self.__class__.__name__}' value changed")

        change = self.input_value_to_be_changed(value_name, change)

        ii = self._input_items[value_name]
        ii.module.set_input(ii.value_name, change.new)

        self.input_value_changed(value_name, change)

    def input_value_to_be_changed(self, item_name: str, change):

        return change

    def input_value_changed(self, item_name: str, change):
        pass

    @property
    def widget(self) -> Widget:

        if self._widget is not None:
            return self._widget

        self._widget = self._create_widget(
            input_items=self._input_items, output_items=self._output_items
        )

        for name, loc in self._input_items.items():
            func = partial(self.set_input_item_value, name)
            self._widget.observe(func, names=name)
        return self._widget

    @abstractmethod
    def _create_widget(
        self,
        input_items: Mapping[str, ValueLocation],
        output_items: Mapping[str, ValueLocation],
    ) -> Widget:
        pass

    def output_value_changed(self, value_name: str, change: Any):

        pass


class InputFilesWidget(ItemWidget):
    def _create_widget(
        self,
        input_items: Mapping[str, ValueLocation],
        output_items: Mapping[str, ValueLocation],
    ) -> Widget:

        print("Creating widget")

        # uploaded_file_details = Output()
        file_upload = FileUpload(accept=".csv", multiple=True)
        file_upload = FileUpload(multiple=True)

        def set_files(change):

            self.set_input_item_value("files", change)
            self.widget._counter = len(change.new)

        file_upload.observe(set_files, names="value")

        return file_upload


class GenericViewer(ItemWidget):
    def _create_widget(
        self,
        input_items: Mapping[str, ValueLocation],
        output_items: Mapping[str, ValueLocation],
    ) -> Widget:

        output = Output()
        return output

    def output_value_changed(self, item_name: str, change):

        print("OUTPUT CHANGED")

        self.widget.clear_output()

        with self.widget:
            rich.jupyter.print(f"Updated: {datetime.now()}")

            rich.jupyter.print(change.new)


class FileSetTable(ItemWidget):
    def _create_widget(
        self,
        input_items: Mapping[str, ValueLocation],
        output_items: Mapping[str, ValueLocation],
    ) -> Widget:

        output = Output()
        return output

    def output_value_changed(self, item_name: str, change):

        print("OUTPUT CHANGED")

        self.widget.clear_output()

        with self.widget:
            print(f"Updated: {datetime.now()}")
            files: DharpaFiles = change.new

            for f in files.files:
                print(f"{f.name}: {f.size}")


# class TextCorpusViewer(ItemWidget):
#     def _create_widget(
#         self,
#         input_items: Mapping[str, ValueLocation],
#         output_items: Mapping[str, ValueLocation],
#     ) -> Widget:
#
#         output = Output()
#         return output
#
#     def output_value_changed(self, item_name: str, change: Any):
#
#         self.widget.clear_output()
#
#         with self.widget:
#             print(f"Updated: {datetime.now()}")
#             tc: TextCorpus = change.new
#             for id, text in tc.corpus().items():
#
#                 if len(text) < 20:
#                     t = text
#                 else:
#                     t = f"{text[0:20]}..."
#                 print(f'{id}: "{t}"')
